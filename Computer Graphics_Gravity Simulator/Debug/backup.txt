// GraphicProject.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <GL/glut.h>
#include <vector>
#define _USE_MATH_DEFINES
#include <cmath>

struct Particle {
	float x;
	float y;
	float r;  //radius
	float ax; //velocity x
	float ay; //velocity y
	float m;  //mass
	float color[3];
};

struct Line {
	float x1;
	float y1;
	float x2;
	float y2;
} line;

void timer(int = 0);
void display();
void mouse(int, int, int, int);
void mouseMotion(int, int);
void addParticle(float, float, bool = true, float = 0, float = 0);
void removeParticles();
void keyboard(unsigned char, int, int);

int Mx, My, WIN;
bool PRESSED_LEFT = false, PRESSED_RIGHT = false,
PRESSED_MIDDLE = false, SPEED_PARTICLES = false;

std::vector<Particle> particles;

int main(int argc, char **argv)
{
	Particle p;
	//initial centered Huge mass particle
	p.x = 0;
	p.y = 0;
	p.ax = p.ay = 0;
	p.m = 5970;
	p.r = 12.756;
	p.color[0] = 0;
	p.color[1] = 0;
	p.color[2] = 1;
	particles.push_back(p);

	glutInit(&argc, argv);  //initialize glut library
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);  //sets the initial display mode
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(50, 50);
	WIN = glutCreateWindow("Gravity Simulator");

	glClearColor(0, 0, 0, 1);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();  // replace the current matrix with the identity matrix
	glOrtho(-250.0, 250.0, 250.0, -250.0, 0, 1);  //multiply the current matrix with an orthographic matrix

	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	glutMotionFunc(mouseMotion);
	glutKeyboardFunc(keyboard);
	timer();

	glutMainLoop();
	return 0;
}

void timer(int)
{
	display();
	if (PRESSED_LEFT && !SPEED_PARTICLES)
	{
		addParticle(10, 3); //add tiny particle
		PRESSED_LEFT = false;
	}

	if (PRESSED_RIGHT)
	{
		addParticle(5970, 12.756, 0); //add huge particle
		PRESSED_RIGHT = false;
	}

	if (PRESSED_MIDDLE)
		removeParticles(); //remove all particles

	for (int i = 0; i < particles.size(); i++)
	{
		Particle &p = particles[i];
		bool not_fall = true;
		for (int j = 0; j < particles.size(); j++)  //comparing one particle to another
		{
			if (j == i || p.m >= 100) // we consider the 100 as infinit (big mass) so this particles won't move
				continue;

			const Particle &p1 = particles[j];

			float d = sqrt((p1.x - p.x)*(p1.x - p.x) + (p1.y - p.y)*(p1.y - p.y));   //Distance between points=phytagoras theorem

			if (d > p1.r)  //distance > p1 radius
			{   //Newton's Acceleration due to gravity theorem
				//ax=G*m/D^2 * cosx , ay=G*m/D^2 * siny
				p.ax += 0.0667 * p1.m / (d*d) * (p1.x - p.x) / d;  //ax+ => acceleration keep increasing after moving (particle getting faster)
				p.ay += 0.0667 * p1.m / (d*d) * (p1.y - p.y) / d;
				       //0.0667=gravitational constant(자유럽게), 원래 =6.67*10^-11
			}
			else
				not_fall = false;   //fall=true, erase particle
		}

		if (not_fall)
		{
			p.x += p.ax;  //set particle coordinate + coordinate from ax and ay
			p.y += p.ay;
		}
		else
			particles.erase(particles.begin() + i);  //delete when falls to the big particle
	}

	glutTimerFunc(1, timer, 0);  //callback, update display() with new saved coordinate
}

void display()
{
	glClear(GL_COLOR_BUFFER_BIT);

	//draw the drag line
	glColor3f(0, 0, 1);
	glBegin(GL_LINES);
	glVertex2f(line.x1, line.y1);
	glVertex2f(line.x2, line.y2);
	glEnd();

	//draw particles
	for (int i = 0; i < particles.size(); i++)
	{
		Particle &p = particles[i];  //get particle data from vector
		glColor3f(p.color[0], p.color[1], p.color[2]);
		glBegin(GL_POLYGON);
		for (float c = 0; c < 2 * 3.14; c += 0.2)  //full circle degree, 2*pi
			glVertex2f(p.r*cos(c) + p.x, p.r*sin(c) + p.y); //x coordinate=r*cos a+saved x coordinate, so does y coordinate
		glEnd();
	}

	glFlush();
	glutSwapBuffers();
}

void mouse(int button, int state, int x, int y)
{
	//set the coordinates
	Mx = x - 250;   //position of x particle after clicked (make it center)
	My = y - 250;

	//add speed particles by line draging
	if (SPEED_PARTICLES)
	{
		if (line.x2 != 0 && line.y2 != 0 && state == GLUT_UP && PRESSED_LEFT)
			addParticle(100, 5, 1, line.x1 - line.x2, line.y1 - line.y2); //add a speed particle
		else
		{
			line.x1 = line.x2 = Mx;
			line.y1 = line.y2 = My;
		}
	}

	//check which button is pressed
	if (button == GLUT_LEFT_BUTTON)
		PRESSED_LEFT = state == GLUT_DOWN;
	else if (button == GLUT_RIGHT_BUTTON)
		PRESSED_RIGHT = state == GLUT_DOWN;
	else if (button == GLUT_MIDDLE_BUTTON)
		PRESSED_MIDDLE = state == GLUT_DOWN;
}

void mouseMotion(int x, int y)
{
	Mx = x - 250;
	My = y - 250;

	//end of line with draging
	if (SPEED_PARTICLES && PRESSED_LEFT)
	{
		line.x2 = Mx;
		line.y2 = My;
	}
}

void addParticle(float m, float r, bool randColor, float ax, float ay)
{
	Particle p;
	p.x = Mx;       //particle position=mouse position
	p.y = My;
	p.ax = ax / 30; // /30 in case it is a speed particle,
	p.ay = ay / 30; // slow down the speed a little
	p.m = m;
	p.r = r;
	if (randColor)  //small particle, change color
	{
		p.color[0] = rand() % 200 / 200.0;
		p.color[1] = rand() % 200 / 200.0;
		p.color[2] = rand() % 200 / 200.0;
	}
	else // if is huge particle make it yellow
	{
		p.color[0] = 1;
		p.color[1] = 1;
		p.color[2] = 0;
	}
	particles.push_back(p);

	if (line.x1 != 0)
		line.x1 = line.x2 = line.y1 = line.y2 = 0;
}

void removeParticles()
{
	for (int i = 0; i < particles.size(); i++)
		particles.pop_back();   //remove particles from vector
}

void keyboard(unsigned char key, int x, int y)
{
	switch (key)
	{
	case 's':
		SPEED_PARTICLES = !SPEED_PARTICLES;
		break;
	case 27:  //esc
		removeParticles();
		glutDestroyWindow(WIN);
		exit(0);
		break;
	}
}